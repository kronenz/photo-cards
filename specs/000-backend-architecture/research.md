# 백엔드 아키텍처 연구 보고서

## 📋 개요

홀로그래픽 카드 커뮤니티 프로젝트의 백엔드 아키텍처 설계를 위한 기술 연구 및 분석 보고서입니다.

## 🎯 연구 목표

1. **최적의 백엔드 아키텍처 설계**
2. **확장성과 성능을 고려한 기술 스택 선택**
3. **비용 효율적인 인프라 구성**
4. **개발자 경험(DX) 최적화**

## 🔍 기술 스택 연구

### 1. 백엔드 프레임워크 비교

#### PocketBase vs 다른 BaaS 솔루션

| 특성 | PocketBase | Firebase | Supabase | AWS Amplify |
|------|------------|----------|----------|-------------|
| **오픈소스** | ✅ 완전 오픈소스 | ❌ 구글 독점 | ✅ 오픈소스 | ❌ AWS 독점 |
| **비용** | ✅ 무료 | 💰 사용량 기반 | 💰 사용량 기반 | 💰 사용량 기반 |
| **자체 호스팅** | ✅ 가능 | ❌ 불가능 | ✅ 가능 | ❌ 불가능 |
| **데이터베이스** | SQLite/PostgreSQL | Firestore | PostgreSQL | DynamoDB |
| **실시간 기능** | ✅ 지원 | ✅ 지원 | ✅ 지원 | ✅ 지원 |
| **파일 저장소** | ✅ 내장 | ✅ 지원 | ✅ 지원 | ✅ 지원 |
| **인증** | ✅ 내장 | ✅ 지원 | ✅ 지원 | ✅ 지원 |
| **API 자동 생성** | ✅ 자동 | ✅ 자동 | ✅ 자동 | ✅ 자동 |
| **Go 언어** | ✅ Go | ❌ | ❌ | ❌ |
| **성능** | ⭐⭐⭐⭐⭐ | ⭐⭐⭐⭐ | ⭐⭐⭐⭐ | ⭐⭐⭐⭐ |

**결론**: PocketBase가 오픈소스, 자체 호스팅, 비용 효율성 측면에서 최적의 선택

#### PocketBase 장점
- **완전 오픈소스**: 코드 수정 및 커스터마이징 가능
- **자체 호스팅**: 데이터 주권 보장, 비용 절약
- **Go 언어**: 높은 성능과 낮은 리소스 사용량
- **내장 기능**: 인증, 파일 저장소, 실시간 기능 모두 포함
- **SQLite 지원**: 개발 환경에서 간편한 설정

#### PocketBase 단점
- **상대적으로 새로운 기술**: 커뮤니티와 문서가 제한적
- **플러그인 생태계**: Firebase/Supabase 대비 제한적
- **클라우드 서비스**: 관리형 서비스 옵션 부족

### 2. 데이터베이스 선택

#### SQLite vs PostgreSQL

| 특성 | SQLite | PostgreSQL |
|------|--------|------------|
| **설치 복잡도** | ✅ 매우 간단 | ⚠️ 중간 |
| **성능** | ⭐⭐⭐⭐ | ⭐⭐⭐⭐⭐ |
| **동시성** | ⚠️ 제한적 | ✅ 우수 |
| **확장성** | ❌ 제한적 | ✅ 우수 |
| **데이터 타입** | ⭐⭐⭐ | ⭐⭐⭐⭐⭐ |
| **JSON 지원** | ⭐⭐⭐ | ⭐⭐⭐⭐⭐ |
| **백업** | ⚠️ 수동 | ✅ 자동화 가능 |
| **클러스터링** | ❌ 불가능 | ✅ 가능 |

**결론**: 
- **개발 환경**: SQLite (간편성)
- **프로덕션 환경**: PostgreSQL (확장성)

### 3. 캐싱 시스템

#### Redis vs Memcached vs In-Memory

| 특성 | Redis | Memcached | In-Memory |
|------|-------|-----------|-----------|
| **데이터 타입** | ✅ 다양한 타입 | ⚠️ 문자열만 | ⚠️ 제한적 |
| **영속성** | ✅ 지원 | ❌ 없음 | ❌ 없음 |
| **클러스터링** | ✅ 지원 | ⚠️ 제한적 | ❌ 없음 |
| **메모리 효율성** | ⭐⭐⭐ | ⭐⭐⭐⭐ | ⭐⭐⭐⭐⭐ |
| **성능** | ⭐⭐⭐⭐ | ⭐⭐⭐⭐⭐ | ⭐⭐⭐⭐⭐ |
| **복잡성** | ⭐⭐⭐ | ⭐⭐⭐⭐⭐ | ⭐⭐⭐⭐⭐ |

**결론**: Redis가 데이터 타입 다양성, 영속성, 클러스터링 지원으로 최적

### 4. 파일 저장소

#### MinIO vs AWS S3 vs Google Cloud Storage

| 특성 | MinIO | AWS S3 | Google Cloud Storage |
|------|-------|--------|---------------------|
| **비용** | ✅ 무료 | 💰 사용량 기반 | 💰 사용량 기반 |
| **자체 호스팅** | ✅ 가능 | ❌ 불가능 | ❌ 불가능 |
| **S3 호환성** | ✅ 완벽 | ✅ 네이티브 | ⚠️ 제한적 |
| **성능** | ⭐⭐⭐⭐ | ⭐⭐⭐⭐⭐ | ⭐⭐⭐⭐⭐ |
| **확장성** | ⭐⭐⭐⭐ | ⭐⭐⭐⭐⭐ | ⭐⭐⭐⭐⭐ |
| **관리 복잡도** | ⭐⭐⭐ | ⭐⭐⭐⭐⭐ | ⭐⭐⭐⭐⭐ |

**결론**: MinIO가 비용 효율성과 S3 호환성으로 최적

## 🏗️ 아키텍처 패턴 연구

### 1. 마이크로서비스 vs 모놀리식

#### 모놀리식 아키텍처 (현재 선택)
**장점:**
- 개발 및 배포 단순성
- 디버깅 용이성
- 트랜잭션 일관성 보장
- 초기 개발 속도

**단점:**
- 확장성 제한
- 기술 스택 고정
- 장애 전파 위험

#### 마이크로서비스 아키텍처 (향후 고려)
**장점:**
- 독립적 확장 가능
- 기술 스택 다양성
- 장애 격리
- 팀별 독립 개발

**단점:**
- 복잡한 운영
- 네트워크 지연
- 데이터 일관성 복잡성
- 디버깅 어려움

**결론**: 초기에는 모놀리식으로 시작하여 점진적으로 마이크로서비스로 전환

### 2. 이벤트 기반 아키텍처

#### 이벤트 소싱
- **장점**: 완전한 감사 추적, 시간 여행 가능
- **단점**: 복잡성 증가, 스토리지 비용
- **적용**: 사용자 활동 추적, 감사 로그

#### CQRS (Command Query Responsibility Segregation)
- **장점**: 읽기/쓰기 최적화, 확장성
- **단점**: 복잡성 증가, 데이터 일관성
- **적용**: 분석 및 리포팅 시스템

### 3. API 설계 패턴

#### RESTful API
- **장점**: 표준화, 캐싱 지원, 간단함
- **단점**: 오버페칭, 언더페칭
- **적용**: 기본 CRUD 작업

#### GraphQL
- **장점**: 클라이언트 요구사항에 맞는 데이터 조회
- **단점**: 복잡성, 캐싱 어려움
- **적용**: 복잡한 데이터 조회 (향후)

## 📊 성능 최적화 연구

### 1. 데이터베이스 최적화

#### 인덱싱 전략
```sql
-- 단일 컬럼 인덱스
CREATE INDEX idx_user_email ON users(email);
CREATE INDEX idx_card_creator ON unified_cards(community_creator);

-- 복합 인덱스
CREATE INDEX idx_card_public_likes ON unified_cards(community_is_public, community_likes);
CREATE INDEX idx_template_category_rating ON templates(category, rating);

-- 부분 인덱스
CREATE INDEX idx_public_cards ON unified_cards(community_likes) 
WHERE community_is_public = true;
```

#### 쿼리 최적화
- **N+1 문제 해결**: JOIN 또는 배치 조회
- **페이지네이션**: 커서 기반 페이지네이션
- **캐싱**: 자주 조회되는 데이터 캐싱

### 2. 캐싱 전략

#### Redis 캐싱 계층
```
L1: 애플리케이션 메모리 캐시
L2: Redis 분산 캐시
L3: 데이터베이스
```

#### 캐시 무효화 전략
- **TTL 기반**: 시간 기반 만료
- **이벤트 기반**: 데이터 변경 시 무효화
- **버전 기반**: 데이터 버전으로 무효화

### 3. CDN 및 정적 자원

#### CDN 선택 기준
- **지리적 분산**: 전 세계 사용자 지원
- **캐시 정책**: 적절한 TTL 설정
- **비용**: 트래픽 기반 비용 고려

## 🔒 보안 연구

### 1. 인증 및 인가

#### JWT vs Session
| 특성 | JWT | Session |
|------|-----|---------|
| **확장성** | ✅ 상태 비저장 | ⚠️ 서버 상태 필요 |
| **보안** | ⚠️ 토큰 탈취 위험 | ✅ 서버 관리 |
| **성능** | ✅ 빠름 | ⚠️ DB 조회 필요 |
| **복잡성** | ⭐⭐⭐ | ⭐⭐⭐⭐ |

**결론**: JWT + Refresh Token 조합 사용

#### OAuth 2.0 구현
- **Authorization Code Flow**: 웹 애플리케이션
- **PKCE**: 모바일 애플리케이션
- **Client Credentials**: 서버 간 통신

### 2. 데이터 보호

#### 암호화 전략
- **전송 중**: TLS 1.3
- **저장 시**: AES-256
- **개인정보**: 필드 레벨 암호화

#### GDPR 준수
- **데이터 최소화**: 필요한 데이터만 수집
- **동의 관리**: 명시적 동의
- **삭제권**: Right to be forgotten
- **데이터 이식성**: 데이터 내보내기

## 📈 모니터링 및 로깅

### 1. 메트릭 수집

#### 시스템 메트릭
- **CPU, 메모리, 디스크**: Prometheus + Node Exporter
- **네트워크**: Prometheus + cAdvisor
- **애플리케이션**: 커스텀 메트릭

#### 비즈니스 메트릭
- **사용자 활동**: DAU, MAU, 세션 시간
- **카드 생성**: 일일 생성 수, 완성률
- **템플릿 사용**: 다운로드 수, 평점

### 2. 로깅 전략

#### 구조화된 로깅
```json
{
  "timestamp": "2024-01-01T00:00:00Z",
  "level": "INFO",
  "service": "pocketbase",
  "message": "User login successful",
  "user_id": "user_123",
  "ip_address": "192.168.1.1",
  "request_id": "req_456"
}
```

#### 로그 레벨
- **ERROR**: 시스템 오류, 예외
- **WARN**: 경고 상황, 성능 이슈
- **INFO**: 일반적인 작업 로그
- **DEBUG**: 디버깅 정보

## 💰 비용 분석

### 1. 인프라 비용 (월간)

#### 자체 호스팅 (VPS)
- **서버**: $50-100 (4-8GB RAM)
- **스토리지**: $20-50 (100-500GB)
- **CDN**: $10-30 (100GB-1TB)
- **총 비용**: $80-180

#### 클라우드 서비스
- **AWS**: $200-500
- **Google Cloud**: $150-400
- **Azure**: $180-450

**결론**: 자체 호스팅이 비용 효율적

### 2. 개발 비용

#### 개발자 생산성
- **PocketBase**: 빠른 프로토타이핑
- **Docker**: 환경 일관성
- **자동화**: CI/CD 파이프라인

#### 유지보수 비용
- **오픈소스**: 커뮤니티 지원
- **문서화**: 체계적인 문서
- **모니터링**: 자동화된 알림

## 🚀 확장성 계획

### 1. 단계별 확장

#### Phase 1: 모놀리식 (현재)
- PocketBase 단일 인스턴스
- SQLite 데이터베이스
- MinIO 단일 노드

#### Phase 2: 수직 확장
- PostgreSQL 마이그레이션
- MinIO 클러스터
- Redis 클러스터

#### Phase 3: 수평 확장
- 마이크로서비스 분리
- API Gateway 도입
- 서비스 메시 구성

### 2. 마이그레이션 전략

#### 데이터베이스 마이그레이션
- **SQLite → PostgreSQL**: pg_dump 사용
- **스키마 변경**: 점진적 마이그레이션
- **데이터 검증**: 무결성 확인

#### 서비스 분리
- **인증 서비스**: 독립적인 인증 서버
- **파일 서비스**: MinIO 전용 서비스
- **알림 서비스**: 실시간 알림 처리

## 📚 참고 자료

### 기술 문서
- [PocketBase 공식 문서](https://pocketbase.io/docs/)
- [MinIO 공식 문서](https://min.io/docs/)
- [Redis 공식 문서](https://redis.io/docs/)
- [PostgreSQL 공식 문서](https://www.postgresql.org/docs/)

### 아키텍처 패턴
- [Microservices Patterns](https://microservices.io/)
- [Domain-Driven Design](https://martinfowler.com/tags/domain%20driven%20design.html)
- [Event Sourcing](https://martinfowler.com/eaaDev/EventSourcing.html)

### 성능 최적화
- [High Performance Browser Networking](https://hpbn.co/)
- [Database Internals](https://www.databass.dev/)
- [Designing Data-Intensive Applications](https://dataintensive.net/)

---

이 연구 보고서를 통해 최적의 백엔드 아키텍처를 설계하고 구현할 수 있습니다. 각 기술 선택의 근거와 장단점을 명확히 하여 프로젝트의 요구사항에 맞는 솔루션을 선택했습니다.
